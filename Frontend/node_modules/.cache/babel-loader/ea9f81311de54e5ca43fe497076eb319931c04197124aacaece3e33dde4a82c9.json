{"ast":null,"code":"/**\r\n * Request Controller Utility\r\n * Handles request cancellation, abort functionality, and request management\r\n */\n\nclass RequestController {\n  constructor() {\n    this.abortControllers = new Map();\n    this.activeRequests = new Map();\n    this.requestTimeouts = new Map();\n  }\n\n  /**\r\n   * Create a new abort controller for a request\r\n   * @param {string} requestId - Unique identifier for the request\r\n   * @returns {AbortController} - AbortController instance\r\n   */\n  createAbortController(requestId) {\n    // Cancel existing request if any\n    this.cancelRequest(requestId);\n\n    // Create new abort controller\n    const controller = new AbortController();\n    this.abortControllers.set(requestId, controller);\n    return controller;\n  }\n\n  /**\r\n   * Get abort controller for a request\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {AbortController|null} - AbortController instance or null\r\n   */\n  getAbortController(requestId) {\n    return this.abortControllers.get(requestId) || null;\n  }\n\n  /**\r\n   * Cancel a specific request\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {boolean} - True if request was cancelled\r\n   */\n  cancelRequest(requestId) {\n    const controller = this.abortControllers.get(requestId);\n    if (controller) {\n      controller.abort();\n      this.abortControllers.delete(requestId);\n      this.activeRequests.delete(requestId);\n      this.clearRequestTimeout(requestId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\r\n   * Cancel all active requests\r\n   */\n  cancelAllRequests() {\n    this.abortControllers.forEach(controller => {\n      controller.abort();\n    });\n    this.abortControllers.clear();\n    this.activeRequests.clear();\n    this.clearAllTimeouts();\n  }\n\n  /**\r\n   * Set request timeout\r\n   * @param {string} requestId - Request identifier\r\n   * @param {number} timeoutMs - Timeout in milliseconds\r\n   * @param {Function} onTimeout - Callback when timeout occurs\r\n   */\n  setRequestTimeout(requestId, timeoutMs, onTimeout) {\n    this.clearRequestTimeout(requestId);\n    const timeoutId = setTimeout(() => {\n      this.cancelRequest(requestId);\n      if (onTimeout) {\n        onTimeout();\n      }\n    }, timeoutMs);\n    this.requestTimeouts.set(requestId, timeoutId);\n  }\n\n  /**\r\n   * Clear request timeout\r\n   * @param {string} requestId - Request identifier\r\n   */\n  clearRequestTimeout(requestId) {\n    const timeoutId = this.requestTimeouts.get(requestId);\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      this.requestTimeouts.delete(requestId);\n    }\n  }\n\n  /**\r\n   * Clear all request timeouts\r\n   */\n  clearAllTimeouts() {\n    this.requestTimeouts.forEach(timeoutId => {\n      clearTimeout(timeoutId);\n    });\n    this.requestTimeouts.clear();\n  }\n\n  /**\r\n   * Mark request as active\r\n   * @param {string} requestId - Request identifier\r\n   * @param {Object} requestInfo - Additional request information\r\n   */\n  markRequestActive(requestId, requestInfo = {}) {\n    this.activeRequests.set(requestId, {\n      startTime: Date.now(),\n      ...requestInfo\n    });\n  }\n\n  /**\r\n   * Mark request as completed\r\n   * @param {string} requestId - Request identifier\r\n   */\n  markRequestCompleted(requestId) {\n    this.activeRequests.delete(requestId);\n    this.abortControllers.delete(requestId);\n    this.clearRequestTimeout(requestId);\n  }\n\n  /**\r\n   * Get active requests count\r\n   * @returns {number} - Number of active requests\r\n   */\n  getActiveRequestsCount() {\n    return this.activeRequests.size;\n  }\n\n  /**\r\n   * Get active requests info\r\n   * @returns {Array} - Array of active request information\r\n   */\n  getActiveRequests() {\n    return Array.from(this.activeRequests.entries()).map(([id, info]) => ({\n      id,\n      ...info\n    }));\n  }\n\n  /**\r\n   * Check if request is active\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {boolean} - True if request is active\r\n   */\n  isRequestActive(requestId) {\n    return this.activeRequests.has(requestId);\n  }\n\n  /**\r\n   * Create a cancellable API request\r\n   * @param {string} requestId - Request identifier\r\n   * @param {Function} apiCall - API call function\r\n   * @param {Object} options - Request options\r\n   * @returns {Promise} - Promise that resolves with API response\r\n   */\n  async createCancellableRequest(requestId, apiCall, options = {}) {\n    const {\n      timeout = 30000,\n      // 30 seconds default\n      onTimeout = null,\n      onCancel = null\n    } = options;\n\n    // Create abort controller\n    const controller = this.createAbortController(requestId);\n\n    // Set timeout if specified\n    if (timeout > 0) {\n      this.setRequestTimeout(requestId, timeout, onTimeout);\n    }\n    try {\n      // Mark request as active\n      this.markRequestActive(requestId, {\n        type: 'api_call',\n        timestamp: new Date().toISOString()\n      });\n\n      // Execute API call with abort signal\n      const result = await apiCall(controller.signal);\n\n      // Mark request as completed\n      this.markRequestCompleted(requestId);\n      return result;\n    } catch (error) {\n      // Handle abort errors\n      if (error.name === 'AbortError') {\n        if (onCancel) {\n          onCancel();\n        }\n        throw new Error('Request was cancelled');\n      }\n\n      // Mark request as completed (even on error)\n      this.markRequestCompleted(requestId);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Create a cancellable long-running operation\r\n   * @param {string} operationId - Operation identifier\r\n   * @param {Function} operation - Operation function\r\n   * @param {Object} options - Operation options\r\n   * @returns {Promise} - Promise that resolves with operation result\r\n   */\n  async createCancellableOperation(operationId, operation, options = {}) {\n    const {\n      timeout = 300000,\n      // 5 minutes default\n      onProgress = null,\n      onTimeout = null,\n      onCancel = null\n    } = options;\n\n    // Create abort controller\n    const controller = this.createAbortController(operationId);\n\n    // Set timeout if specified\n    if (timeout > 0) {\n      this.setRequestTimeout(operationId, timeout, onTimeout);\n    }\n    try {\n      // Mark operation as active\n      this.markRequestActive(operationId, {\n        type: 'long_operation',\n        timestamp: new Date().toISOString()\n      });\n\n      // Execute operation with abort signal and progress callback\n      const result = await operation(controller.signal, onProgress);\n\n      // Mark operation as completed\n      this.markRequestCompleted(operationId);\n      return result;\n    } catch (error) {\n      // Handle abort errors\n      if (error.name === 'AbortError') {\n        if (onCancel) {\n          onCancel();\n        }\n        throw new Error('Operation was cancelled');\n      }\n\n      // Mark operation as completed (even on error)\n      this.markRequestCompleted(operationId);\n      throw error;\n    }\n  }\n\n  /**\r\n   * Clean up resources\r\n   */\n  cleanup() {\n    this.cancelAllRequests();\n    this.clearAllTimeouts();\n  }\n}\n\n// Create singleton instance\nconst requestController = new RequestController();\nexport default requestController;\n\n// Export individual methods for convenience\nexport const {\n  createAbortController,\n  getAbortController,\n  cancelRequest,\n  cancelAllRequests,\n  setRequestTimeout,\n  clearRequestTimeout,\n  markRequestActive,\n  markRequestCompleted,\n  getActiveRequestsCount,\n  getActiveRequests,\n  isRequestActive,\n  createCancellableRequest,\n  createCancellableOperation,\n  cleanup\n} = requestController;","map":{"version":3,"names":["RequestController","constructor","abortControllers","Map","activeRequests","requestTimeouts","createAbortController","requestId","cancelRequest","controller","AbortController","set","getAbortController","get","abort","delete","clearRequestTimeout","cancelAllRequests","forEach","clear","clearAllTimeouts","setRequestTimeout","timeoutMs","onTimeout","timeoutId","setTimeout","clearTimeout","markRequestActive","requestInfo","startTime","Date","now","markRequestCompleted","getActiveRequestsCount","size","getActiveRequests","Array","from","entries","map","id","info","isRequestActive","has","createCancellableRequest","apiCall","options","timeout","onCancel","type","timestamp","toISOString","result","signal","error","name","Error","createCancellableOperation","operationId","operation","onProgress","cleanup","requestController"],"sources":["F:/Local disk c/Session Web 2.0/Frontend/src/utils/requestController.js"],"sourcesContent":["/**\r\n * Request Controller Utility\r\n * Handles request cancellation, abort functionality, and request management\r\n */\r\n\r\nclass RequestController {\r\n  constructor() {\r\n    this.abortControllers = new Map();\r\n    this.activeRequests = new Map();\r\n    this.requestTimeouts = new Map();\r\n  }\r\n\r\n  /**\r\n   * Create a new abort controller for a request\r\n   * @param {string} requestId - Unique identifier for the request\r\n   * @returns {AbortController} - AbortController instance\r\n   */\r\n  createAbortController(requestId) {\r\n    // Cancel existing request if any\r\n    this.cancelRequest(requestId);\r\n    \r\n    // Create new abort controller\r\n    const controller = new AbortController();\r\n    this.abortControllers.set(requestId, controller);\r\n    \r\n    return controller;\r\n  }\r\n\r\n  /**\r\n   * Get abort controller for a request\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {AbortController|null} - AbortController instance or null\r\n   */\r\n  getAbortController(requestId) {\r\n    return this.abortControllers.get(requestId) || null;\r\n  }\r\n\r\n  /**\r\n   * Cancel a specific request\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {boolean} - True if request was cancelled\r\n   */\r\n  cancelRequest(requestId) {\r\n    const controller = this.abortControllers.get(requestId);\r\n    if (controller) {\r\n      controller.abort();\r\n      this.abortControllers.delete(requestId);\r\n      this.activeRequests.delete(requestId);\r\n      this.clearRequestTimeout(requestId);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Cancel all active requests\r\n   */\r\n  cancelAllRequests() {\r\n    this.abortControllers.forEach(controller => {\r\n      controller.abort();\r\n    });\r\n    \r\n    this.abortControllers.clear();\r\n    this.activeRequests.clear();\r\n    this.clearAllTimeouts();\r\n  }\r\n\r\n  /**\r\n   * Set request timeout\r\n   * @param {string} requestId - Request identifier\r\n   * @param {number} timeoutMs - Timeout in milliseconds\r\n   * @param {Function} onTimeout - Callback when timeout occurs\r\n   */\r\n  setRequestTimeout(requestId, timeoutMs, onTimeout) {\r\n    this.clearRequestTimeout(requestId);\r\n    \r\n    const timeoutId = setTimeout(() => {\r\n      this.cancelRequest(requestId);\r\n      if (onTimeout) {\r\n        onTimeout();\r\n      }\r\n    }, timeoutMs);\r\n    \r\n    this.requestTimeouts.set(requestId, timeoutId);\r\n  }\r\n\r\n  /**\r\n   * Clear request timeout\r\n   * @param {string} requestId - Request identifier\r\n   */\r\n  clearRequestTimeout(requestId) {\r\n    const timeoutId = this.requestTimeouts.get(requestId);\r\n    if (timeoutId) {\r\n      clearTimeout(timeoutId);\r\n      this.requestTimeouts.delete(requestId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all request timeouts\r\n   */\r\n  clearAllTimeouts() {\r\n    this.requestTimeouts.forEach(timeoutId => {\r\n      clearTimeout(timeoutId);\r\n    });\r\n    this.requestTimeouts.clear();\r\n  }\r\n\r\n  /**\r\n   * Mark request as active\r\n   * @param {string} requestId - Request identifier\r\n   * @param {Object} requestInfo - Additional request information\r\n   */\r\n  markRequestActive(requestId, requestInfo = {}) {\r\n    this.activeRequests.set(requestId, {\r\n      startTime: Date.now(),\r\n      ...requestInfo\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Mark request as completed\r\n   * @param {string} requestId - Request identifier\r\n   */\r\n  markRequestCompleted(requestId) {\r\n    this.activeRequests.delete(requestId);\r\n    this.abortControllers.delete(requestId);\r\n    this.clearRequestTimeout(requestId);\r\n  }\r\n\r\n  /**\r\n   * Get active requests count\r\n   * @returns {number} - Number of active requests\r\n   */\r\n  getActiveRequestsCount() {\r\n    return this.activeRequests.size;\r\n  }\r\n\r\n  /**\r\n   * Get active requests info\r\n   * @returns {Array} - Array of active request information\r\n   */\r\n  getActiveRequests() {\r\n    return Array.from(this.activeRequests.entries()).map(([id, info]) => ({\r\n      id,\r\n      ...info\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Check if request is active\r\n   * @param {string} requestId - Request identifier\r\n   * @returns {boolean} - True if request is active\r\n   */\r\n  isRequestActive(requestId) {\r\n    return this.activeRequests.has(requestId);\r\n  }\r\n\r\n  /**\r\n   * Create a cancellable API request\r\n   * @param {string} requestId - Request identifier\r\n   * @param {Function} apiCall - API call function\r\n   * @param {Object} options - Request options\r\n   * @returns {Promise} - Promise that resolves with API response\r\n   */\r\n  async createCancellableRequest(requestId, apiCall, options = {}) {\r\n    const {\r\n      timeout = 30000, // 30 seconds default\r\n      onTimeout = null,\r\n      onCancel = null\r\n    } = options;\r\n\r\n    // Create abort controller\r\n    const controller = this.createAbortController(requestId);\r\n    \r\n    // Set timeout if specified\r\n    if (timeout > 0) {\r\n      this.setRequestTimeout(requestId, timeout, onTimeout);\r\n    }\r\n\r\n    try {\r\n      // Mark request as active\r\n      this.markRequestActive(requestId, {\r\n        type: 'api_call',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // Execute API call with abort signal\r\n      const result = await apiCall(controller.signal);\r\n      \r\n      // Mark request as completed\r\n      this.markRequestCompleted(requestId);\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      // Handle abort errors\r\n      if (error.name === 'AbortError') {\r\n        if (onCancel) {\r\n          onCancel();\r\n        }\r\n        throw new Error('Request was cancelled');\r\n      }\r\n      \r\n      // Mark request as completed (even on error)\r\n      this.markRequestCompleted(requestId);\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a cancellable long-running operation\r\n   * @param {string} operationId - Operation identifier\r\n   * @param {Function} operation - Operation function\r\n   * @param {Object} options - Operation options\r\n   * @returns {Promise} - Promise that resolves with operation result\r\n   */\r\n  async createCancellableOperation(operationId, operation, options = {}) {\r\n    const {\r\n      timeout = 300000, // 5 minutes default\r\n      onProgress = null,\r\n      onTimeout = null,\r\n      onCancel = null\r\n    } = options;\r\n\r\n    // Create abort controller\r\n    const controller = this.createAbortController(operationId);\r\n    \r\n    // Set timeout if specified\r\n    if (timeout > 0) {\r\n      this.setRequestTimeout(operationId, timeout, onTimeout);\r\n    }\r\n\r\n    try {\r\n      // Mark operation as active\r\n      this.markRequestActive(operationId, {\r\n        type: 'long_operation',\r\n        timestamp: new Date().toISOString()\r\n      });\r\n\r\n      // Execute operation with abort signal and progress callback\r\n      const result = await operation(controller.signal, onProgress);\r\n      \r\n      // Mark operation as completed\r\n      this.markRequestCompleted(operationId);\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      // Handle abort errors\r\n      if (error.name === 'AbortError') {\r\n        if (onCancel) {\r\n          onCancel();\r\n        }\r\n        throw new Error('Operation was cancelled');\r\n      }\r\n      \r\n      // Mark operation as completed (even on error)\r\n      this.markRequestCompleted(operationId);\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  cleanup() {\r\n    this.cancelAllRequests();\r\n    this.clearAllTimeouts();\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nconst requestController = new RequestController();\r\n\r\nexport default requestController;\r\n\r\n// Export individual methods for convenience\r\nexport const {\r\n  createAbortController,\r\n  getAbortController,\r\n  cancelRequest,\r\n  cancelAllRequests,\r\n  setRequestTimeout,\r\n  clearRequestTimeout,\r\n  markRequestActive,\r\n  markRequestCompleted,\r\n  getActiveRequestsCount,\r\n  getActiveRequests,\r\n  isRequestActive,\r\n  createCancellableRequest,\r\n  createCancellableOperation,\r\n  cleanup\r\n} = requestController;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}